{
    "apiVersion": "v1",
    "kind": "ConfigMap",
    "metadata": {
        "name": "f8c01fa1-03a8-5108-82e9-5cb7cdd0a969",
        "namespace": "test-runner",
        "labels": {}
    },
    "data": {
        "simple-addition-chaincode.go": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/hyperledger/fabric/core/chaincode/shim\"\n\tpb \"github.com/hyperledger/fabric/protos/peer\"\n\t\"strconv\"\n)\n\nconst errorWrongFormat = \"{\\\"code\\\":301, \\\"reason\\\": \\\"Could not find an appropriate command. Must be 'update'\\\"}\"\n\ntype SimpleAdditionChaincode struct {\n}\n\nfunc (s *SimpleAdditionChaincode) Init(stub shim.ChaincodeStubInterface) pb.Response {\n\treturn shim.Success(nil)\n}\n\nfunc (s *SimpleAdditionChaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response {\n\tfunction, args := stub.GetFunctionAndParameters()\n\n\tif function == \"update\" {\n\t\treturn s.update(stub, args)\n\t}\n\n\treturn shim.Error(errorWrongFormat)\n}\n\nfunc (s *SimpleAdditionChaincode) update(stub shim.ChaincodeStubInterface, args []string) pb.Response {\n\t// Check we have a valid number of args\n\tif len(args) != 3 {\n\t\treturn shim.Error(\"Incorrect number of arguments, expecting 3\")\n\t}\n\n\t// Extract the args\n\tname := args[0]\n\top := args[2]\n\t_, err := strconv.ParseFloat(args[1], 64)\n\tif err != nil {\n\t\treturn shim.Error(\"Provided value was not a number\")\n\t}\n\n\t// Make sure a valid operator is provided\n\tif op != \"+\" && op != \"-\" {\n\t\treturn shim.Error(fmt.Sprintf(\"Operator %s is unrecognized\", op))\n\t}\n\n\t// Retrieve info needed for the update procedure\n\ttxid := stub.GetTxID()\n\tcompositeIndexName := \"varName~op~value~txID\"\n\n\t// Create the composite key that will allow us to query for all deltas on a particular variable\n\tcompositeKey, compositeErr := stub.CreateCompositeKey(compositeIndexName, []string{name, op, args[1], txid})\n\tif compositeErr != nil {\n\t\treturn shim.Error(fmt.Sprintf(\"Could not create a composite key for %s: %s\", name, compositeErr.Error()))\n\t}\n\n\t// Save the composite key index\n\tcompositePutErr := stub.PutState(compositeKey, []byte{0x00})\n\tif compositePutErr != nil {\n\t\treturn shim.Error(fmt.Sprintf(\"Could not put operation for %s in the ledger: %s\", name, compositePutErr.Error()))\n\t}\n\n\treturn shim.Success([]byte(fmt.Sprintf(\"Successfully added %s%s to %s\", op, args[1], name)))\n}\n\nfunc main() {\n\terr := shim.Start(new(SimpleAdditionChaincode))\n\tif err != nil {\n\t\tfmt.Printf(\"Error starting chaincode: %v \\n\", err)\n\t}\n}\n"
    }
}